#!/bin/sh

die()
{
	echo "$1" >&2
	exit 1
}

if [ $# -ne 2 ]; then
	die "Usage: debian-build-repo <pkgs_dir> <repo_dir>"
fi

if [ -z "$KEY_ID" ] && [ -z "$SKIP_SIGN" ]; then
	die "Environment variable KEY_ID is unset; must be set to the ID of the signing key."
fi

get_tempdir()
{
	echo "tmp/"
}

cleanup_workspace()
{
	! [ -z "$TMPDIR" ] && [ -d "$TMPDIR" ] && rm -rf "$TMPDIR"
	exit 0
}

init_workspace()
{
	TMPDIR="$(get_tempdir)"
}

get_workdir()
{
	local name="$1"
	echo "$TMPDIR/$name"
}

on_exit()
{
	cleanup_workspace
}

trap on_exit EXIT

PKGDIR="$1"
REPODIR="$2"

find_debs()
{
	(cd "$1"; du -a . | awk '{print $2}' | grep '\.deb$' | sed -e 's|^./||')
}

get_compress_opt()
{
	local filename="$1"
	case "$filename" in
	  *.gz)
		echo "-z"
	  ;;
 	  *.bz2)
	        echo "-j"
	  ;;
	  *.xz)
	        echo "-J"
	  ;;
	  *.lzma)
	        echo "--lzma"
	  ;;
	  *.tar)
	        echo ""
	  ;;
	  *)
		die "Urecognized file extension for archive $pkgfile"
	esac
}

extract_control()
{
	local pkgfile="$1"
	local control_file="$(ar t "$pkgfile" | grep '^control\.' | sed 1q)" || die "Unable to locate control archive for package $pkgfile"
	local compress_opt="$(get_compress_opt "$control_file")" || die "Unable to determine decompression option for $pkgfile"
	ar p "$pkgfile" "$control_file" | tar -O $compress_opt -xf - ./control || die "Failure extracting control file from package $pkgfile"
}

trim_word()
{
	echo "$1" | (read word; echo $word)
}

control_arch()
{
	local file="$1"
	test -f "$file" || die "Control file $file does not exist."
	local arch="$(trim_word "$(grep '^Architecture: ' "$file" | sed -e 's/^Architecture: \(.*\)/\1/')")"
	if [ $? -ne 0 ] || [ -z "$arch" ]; then
		die "Unable to determine package architecture"
	fi
	echo $arch
}

control_description()
{
	local file="$1"
	awk '
BEGIN { do_print=0; }
/^[^ ]/ { if (do_print) do_print = 0; }
/^Description: / { do_print = 1; }
{ if (do_print) print $0; }
' "$file" | sed -e 's/^Description: //'
	
}

extract_package_info()
{
	local pool_path="$1"
	# pool-relative path to the package.
	local pkg_pool_path="$2"
	local pkg_meta_dir="$3"

	local debfile="$pool_path/$pkg_pool_path"

	rm -rf "$pkg_meta_dir"
	mkdir -p "$pkg_meta_dir"

	local control_file="$(ar t "$debfile" | sed -n '2p')"
	local data_file="$(ar t "$debfile" | sed -n '3p')"

	local control_decompress_opt="$(get_compress_opt "$control_file")"
	local data_decompress_opt="$(get_compress_opt "$data_file")"

	extract_control "$debfile" > "$pkg_meta_dir/control" || die "Unable to extract package control file"

	local ARCH="$(control_arch "$pkg_meta_dir/control")" || die "Unabled to extract package architecture"
	echo "$ARCH" > "$pkg_meta_dir/architecture"

	# Link the package file.
	ln -s "$debfile" "$pkg_meta_dir/package.deb"

	# Record the package's pool-relative path
	echo "$pkg_pool_path" > "$pkg_meta_dir/path"
}

build_packages_entry()
{
	# pkg-dir-relative package file name
	local pkg_metadir="$1"
	local packages_file="$2"

	local control_file="$pkg_metadir/control"

	if [ -s "$packages_file" ]; then
		echo ""
	fi

	# Packages paragraphs must begin with the Package: field, so make sure that happens.
	local package_field_count="$(grep '^Package: ' "$control_file" | wc -l)"
	if [ "$package_field_count" -gt 1 ]; then
		die "Package has multiple Package: entries, control file is invalid."
	fi

	local package_field="$(grep '^Package: ' "$control_file" | sed 1q)" || die "Package control file does not include a Package field, it is invalid."
	echo "$package_field"

	local description="$(control_description "$control_file")" || die "Unable to extract package control description"
	echo "$description" > latest_description.txt
	local md5sum_checksum="$(echo "$description" | md5sum | awk '{print $1}')" || die "Error checksumming package description"
	# Note that we avoid stripping possibly invalid duplicate Package:
	# fields by bailing out if there is more than one of them above.
	cat "$control_file" | grep -v '^Package: ' || die "Error copying package control paragraph to Packages index"
	echo "Description-md5sum: $md5sum_checksum"
	echo "Filename: pool/$(cat "$pkg_metadir/path")" || die "Unable to write pool-relative package path (!)"
	echo "Size: $(du -b "$(readlink "$pkg_metadir/package.deb")" | cut -f 1)"
	echo "SHA256: $(sha256sum $(readlink "$pkg_metadir/package.deb") | awk '{print $1}')" || die "Unable to compute package checksum"
	echo "SHA512: $(sha512sum $(readlink "$pkg_metadir/package.deb") | awk '{print $1}')" || die "Unable to compute package checksum"
}

lines_list()
{
	local separator="$1"
	local input="$2"
	local list=""
	echo "$input" |
	(while IFS="" read -r item; do
		if ! [ -z "$list" ]; then
			list="${list}${separator}"
		fi
		list="${list}${item}"
	done; echo $list)
}

file_hash_info()
{
	local algo="$1"
	local base_dir="$2"
	local path="$3"

	local hash_cmd="${algo}sum"

	# <hash> <byte size> <path> (du provides both path and size -- be careful about the paths used)
	(cd "$base_dir"; echo "$("$hash_cmd" "$path" | awk '{print $1}') $(du -b $path)")
}

build_release()
{
	local repo="$1"
	local meta="$2"

	local packages_sha256="$(file_hash_info sha256 "$meta" Packages)" || die "Unable to checksum Packages index"
	local packages_sha512="$(file_hash_info sha512 "$meta" Packages)" || die "Unable to checksum Packages index"

	local arches="$(ls "$meta/architectures")"
	echo "Architectures: $(lines_list " " "$arches")"
	echo "Date: $(date -R -u)"
	echo "NotAutomatic: yes"
	echo "ButAutomaticUpgrades: yes"
	echo "SHA256:"
	echo " $packages_sha256"
	echo "SHA512:"
	echo " $packages_sha512"
}

build_dist_meta()
{
	local meta="$1"
	echo "Building release index" >&2
	build_release "$2" "$1" > "$meta/Release" || die "Failed to build Release file"

	if ! [ -z "$SKIP_SIGN" ]; then
		exit 0
	fi
	echo "Creating clearsigned InRelease index" >&2
	gpg -a -s --clearsign --local-user "$KEY_ID" --output "$meta/InRelease" "$meta/Release" || die "Failed to create signed InRelease file"
	echo "Creating detached Release index signature" >&2
	gpg -a -b -s --local-user "$KEY_ID" --output "$meta/Release.gpg" "$meta/Release" || die "Failed to create detached signature file for Release index"
	echo "Exporting signing key" >&2
	gpg -a --export --output "$meta/Key.gpg" "$KEY_ID" || die "Failed to export public signing key"
}

copy_meta_to_repo()
{
	local meta="$1"
	local repo_dir="$2"

	cp "$meta/Release" "$meta/InRelease" "$meta/Release.gpg" "$repo_dir" || dir "Failed to copy release index files"
	cp "$meta/Packages" "$repo_dir" || die "Failed to copy Packages index"
	cp "$meta/Key.gpg" "$repo_dir" || die "Failed to copy signing key"
}

add_packages_to_repo()
{
	local pkg_dir="$1"
	local meta_dir="$2"

	local index="$meta_dir/Packages"
	local pkg_meta_dir="$(get_workdir pkg)"
	while IFS="" read -r pkg; do
		echo "Updating repo with package $pkg..." >&2
		rm -rf "$pkg_meta_dir"
		mkdir -p "$pkg_meta_dir"
		extract_package_info "$pkg_dir" "$pkg" "$pkg_meta_dir" || die "Unable to extract package information for package $pkg"

		# Update the set of architectures.
		mkdir -p "$meta_dir/architectures/"
		touch "$meta_dir/architectures/$(cat "$pkg_meta_dir/architecture")" || die "Unable to record package architecture in repo meta"

		if ! [ -s "$index" ]; then
			echo "" >> "$index"
		fi
		build_packages_entry "$pkg_meta_dir" >> "$index"
	done
}

build_repo()
{
	local pkg_dir="$1"
	local repo_dir="$2"

	local meta_dir="$(get_workdir meta)"

	rm -rf "$meta_dir"
	mkdir -p "$meta_dir"

	find_debs "$pkg_dir" > "$meta_dir/pkglist" || die "Error locating package files"
	add_packages_to_repo "$pkg_dir" "$meta_dir" <"$meta_dir/pkglist" || die "Error adding packages to repo"

	build_dist_meta "$meta_dir" || die "Failure building Release information"

	rm -rf "$repo_dir"
	mkdir -p "$repo_dir"
	local pkg_path="$(readlink -f "$pkg_dir")"
	# Link in the package pool
	ln -s "$pkg_path" "$repo_dir/pool"
	copy_meta_to_repo "$meta_dir" "$repo_dir" || die "Failed to copy repository information to repository"
}

init_workspace || die "Failed to set up workspace"
build_repo "$PKGDIR" "$REPODIR" || die "Failure building repo at $REPODIR"
